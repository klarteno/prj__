digraph domain {
  edge [ fontsize = 11 ];
  node [ shape=record ];
  subgraph cluster_0 {
    label = "org.agents.planning";
    GroupIndependenceDetection [ label = "{GroupIndependenceDetection | + getFirstColide() : int\l+ getSecondColide() : int\l+ isColide() : boolean\l+ runIndependenceDetection() : boolean\l}" ] 
    GroupSearch [ label = "{GroupSearch | + getConflictAvoidanceCheckingRules() : ConflictAvoidanceCheckingRules\l+ getSearchMATaskResult(sched_group : SearchScheduled, conflicting_group : int[], conflicting_paths : int[][][]) : SearchTaskResult\l+ runAgentsBoxesSearchMA(sched_group : SearchScheduled, conflicting_group : int[], conflicting_paths : int[][][]) : SearchTaskResult\l+ runAgentsSearchMA(sched_group : SearchScheduled, conflicting_group : int[], conflicting_paths : int[][][]) : SearchTaskResult\l+ runGroupIndependenceDetection(sched_group : SearchScheduled) : SearchTaskResult\l+ runGroupIndependenceDetection(sched_group : SearchScheduled, conflicting_group : int[], conflicting_paths : int[][][]) : SearchTaskResult\l+ runGroupSearch(sched_group : SearchScheduled, conflicting_group : int[], conflicting_paths : int[][][]) : SearchTaskResult\l+ setNextTracked(start_group_agents : int[])\l+ setSearchState(searchState : SearchState)\l+ setUpIndependenceDetection()\l}" ] 
    SearchStrategy [ label = "{SearchStrategy | + getPathsSequencial() : ArrayDeque<ListIterator<String>>\l+ runDescenteralizedSearch() : TaskScheduled\l+ runSearch(searchEngine : SearchEngineSA, movable_id : int) : SearchTaskResult\l}" ] 
  }
  subgraph cluster_1 {
    label = "org.agents.action";
    Action [ label = "{Action | + EveryBox(agentLocation : int[], exceptAction : Action) : List<Action>\l+ EveryMove(agentLocation : int[], exceptAction : Action) : Stack<Action>\l+ getAgentLocation() : int[]\l+ getNewAgentLocation() : int[]\l+ getOpposite() : Action\l+ getType() : ActionType\l+ isOpposite(Action) : boolean\l+ toString() : String\l}" ] 
    ActionType [ label = "{ActionType | + valueOf(String) : ActionType\l+ values() : ActionType[]\l}" ] 
    CellLocation [ label = "{CellLocation | + getX(point : long) : int\l+ getY(point : long) : int\l+ point(x : int, y : int) : long\l}" ] 
    ConflictingPair [ label = "{ConflictingPair | }" ] 
    CoordinateOf3 [ label = "{CoordinateOf3 | }" ] 
    Direction [ label = "{Direction | + getDirectionsFrom(from_cell : int[], destination_cell : int[]) : Direction\l+ getDirectionsFrom(from_cell_locations : int[], destination_cell_locations : int[], index_agents : int[]) : Direction[]\l+ getDirectionsFrom(from_row : int, from_col : int, to_row : int, to_col : int) : Direction\l+ getDirectionsFromOf(from_cell_locations : int[], destination_cell_locations : int[], all_coordinates : boolean) : Direction[]\l+ getNextCellFrom(position_cell : int[])\l+ getOpposite() : Direction\l+ isOpposite(d1 : Direction, d2 : Direction) : boolean\l+ toString() : String\l+ valueOf(String) : Direction\l+ values() : Direction[]\l}" ] 
    Location [ label = "{Location | + getCoordinates() : int[]\l+ getX() : int\l+ getY() : int\l+ newLocation(cell_position : int[], next_direction : Direction) : int[]\l}" ] 
    MoveAction [ label = "{MoveAction | + getOpposite() : Action\l+ isOpposite(action : Action) : boolean\l+ toString() : String\l}" ] 
    Pair2 [ label = "{Pair2 | + getFirst() : short\l+ getPair() : int\l+ getSecond() : short\l}" ] 
    PairOf3 [ label = "{PairOf3 | + getFirst() : byte\l+ getPair() : int\l+ getSecond() : byte\l+ getThird() : byte\l}" ] 
    PullAction [ label = "{PullAction | + getAgentDir() : Direction\l+ getBoxDir() : Direction\l+ getOpposite() : Action\l+ isOpposite(action : Action) : boolean\l+ toString() : String\l}" ] 
    PushAction [ label = "{PushAction | + getAgentDir() : Direction\l+ getBoxDir() : Direction\l+ getOpposite() : Action\l+ isOpposite(action : Action) : boolean\l+ toString() : String\l}" ] 
  }
  subgraph cluster_2 {
    label = "org.agents";
    Agent [ label = "{Agent | + addGoalPosition(next_goal_cell : int[])\l+ getColor() : int\l+ getColumnPosition() : int\l+ getCoordinates() : int[]\l+ getGoalStopPosition() : int[]\l+ getNextGoal() : int[]\l+ getNumberMark() : int\l+ getRowPosition() : int\l+ getSolvedStatus() : SolvedStatus\l+ getTimePosition() : int\l+ setCoordinatesPosition(pos_coordinates : int[])\l+ setCoordinatesPosition(row : int, col : int)\l+ setGoalStopPosition(goal : int[])\l+ setGoalStopPosition(goal_row : int, goal_column : int)\l+ setSolvedStatus(stepSolved : SolvedStatus)\l+ setTimePosition(step_time : int)\l+ updatePositionCoordinates() : boolean\l+ valid(pos : int) : boolean\l}" ] 
    Box [ label = "{Box | + addNeighbourGoal(next_goal_cell : int[])\l+ getColor() : int\l+ getColumnPosition() : int\l+ getCoordinates() : int[]\l+ getCostHeuristic() : int\l+ getGoalPosition() : int[]\l+ getLetterMark() : int\l+ getNeighbourGoal() : int[]\l+ getRowPosition() : int\l+ getSolvedStatus() : SolvedStatus\l+ getTimeStep() : int\l+ setColumnPosition(pos : int)\l+ setGoalPosition(goal_row : int, goal_column : int)\l+ setRowPosition(pos : int)\l+ setSolvedStatus(solvedStatus : SolvedStatus) : boolean\l+ setTimeStep(step_time : int)\l+ valid(pos : int) : boolean\l}" ] 
    MapFixedObjects [ label = "{MapFixedObjects | + getAgents() : LinkedList<Agent>\l+ getAgentsByColor(color_no : Integer) : ArrayDeque<Agent>\l+ getAgentsMarks() : Set<Integer>\l+ getAllBoxesIds() : Set<Integer>\l+ getAllIdsMarks() : Set<Integer>\l+ getBoxByID(box_id : Integer) : Box\l+ getBoxes() : Set<Box>\l+ getBoxesIDsByColor(color_no : Integer) : ArrayDeque<Box>\l+ getBoxesIDsByColor(key_color : Integer, keySet : Set<Integer>) : ArrayDeque<Integer>\l+ getBoxesMarks() : Set<Integer>\l+ getByAgentMarkId(mark_id : int) : Agent\l+ getByBoxMarkId(id : int) : Box\l+ getByMarkNo(movable_id : int) : Serializable\l+ getByMarkNo(movable_ids : int[]) : ArrayDeque<Serializable>\l+ getIndexFor(movable_id : int) : int\l+ getManhattenHeuristic(cell_coordinates : int[], goal_coordinates : int[]) : int\l+ getMarkingsIndexes() : HashMap<Integer, Integer>\l+ getMovableObject(movable_id : int) : Serializable\l+ getNeighbours(coordinates : int[], color_movable : Color) : ArrayDeque<int[]>\l+ getNeighbours(coordinates : int[], mark_id : int) : ArrayDeque<int[]>\l+ getNeighboursMA(position_to_expand : int[], time_deadline : int) : LinkedList<int[]>\l+ getNextBoxBy(color : int) : Optional<Box>\l+ getNumerOfAgents() : int\l+ getNumerOfBoxes() : int\l+ getTrackedMarkingsIDs() : Set<Integer>\l+ getWalls() : boolean[][]\l+ isEmptyCell(cell_position : int[]) : boolean\l+ isFreeCell(cell : int[], mark_id : int) : boolean\l+ setAgents(agents : Agent[]) : boolean\l+ setBoxes(boxes : Box[]) : boolean\l+ setMovables(agents_ : Agent[], boxes_ : Box[])\l+ setUpTrackedMovables(agents : Agent[], boxes : Box[])\l+ setWalls(walls_marks : boolean[][])\l+ updateAgentsByColor() : HashMap<Integer, ArrayDeque<Agent>>\l+ updateBoxesByColor() : HashMap<Integer, ArrayDeque<Box>>\l}" ] 
    SearchClient [ label = "{SearchClient | + initObjects() : MapFixedObjects\l+ initObjects(rows_init_map_marks : Vector<char[]>, goal_map_marks : Vector<char[]>, colors : HashMap<String, Color>, maxCol_map : int) : MapFixedObjects\l+ parse()\l+ parse_map_data(maxCol_map_no : int, rows_map_marks : Vector<char[]>, line : String) : int\l}" ] 
    ParsingState [ label = "{ParsingState | + valueOf(String) : ParsingState\l+ values() : ParsingState[]\l}" ] 
    Utils [ label = "{Utils | + getOrderedColectionOf(array : ArrayList<Integer>) : int[]\l+ isTheRightCoordinatesToLog(pos_coordinates : int[], time0 : int, row_0 : int, col_0 : int, row_1 : int, col_1 : int) : boolean\l+ logAppendToFile(fileName : String, current_state : int[][], size : int)\l+ logAppendToFile(logFileName : String, str_message : String)\l+ logStartForFile(fileName : String)\l+ maxIndexOf(array : int[]) : int\l+ min(array : int[]) : int\l+ min2(array : int[]) : int\l+ minIndexOf(array : int[]) : int\l+ minIndexOf(array : int[], from_idexes : Integer[]) : int\l}" ] 
  }
  subgraph cluster_3 {
    label = "org.agents.searchengine";
    PathProcessing [ label = "{PathProcessing | + getBoxMoves(agent : Agent, agent_cell : int[], box_path : ArrayDeque<int[]>) : ArrayList<String>\l+ getMAAgentBoxesMoves(searchTaskResult : SearchTaskResult) : ArrayList<String[]>\l+ getMAAgentMoves(path : ArrayDeque<int[]>) : ArrayList<String>\l+ getMAAgentMoves(path : ArrayDeque<int[]>, index_agents : int[]) : ArrayList<String[]>\l+ getValidAgentsGoalCoordinates(searchTaskResult : SearchTaskResult) : int[]\l+ get_moves_agent_goal(agent : Agent, searchEngine : SearchEngineSA) : ArrayList<String>\l+ get_moves_agent_goal(agent : Agent, searchEngineSANormal : SearchEngineSANormal) : ArrayList<String>\l+ outputPathsMA(agents_paths : ArrayDeque<int[]>) : ArrayList<String[]>\l+ resetTimeSteps(new_path_one : ArrayDeque<int[]>)\l+ selectCellForAgent(next_neighbours : Stream<int[]>) : int[]\l}" ] 
    SearchEngineOD [ label = "{SearchEngineOD | + getGoalsCoordinatesOfGroup() : int[]\l+ getHeuristic(cell_coordinates : int[], goal_coordinates : int[]) : int\l+ getPath() : SearchTaskResult\l+ getPathCost() : int\l+ getStartCoordinatesOfGroup() : int[]\l+ isPathFound() : boolean\l+ runOperatorDecomposition()\l}" ] 
    SearchEngineSA [ label = "{SearchEngineSA | + getCostCoordinate(cell_coordinate : int[], new_g_cost : int) : int\l+ getHeuristic(cell_coordinate : int[], goal_coordinate : int[]) : int\l+ getPath() : SearchTaskResult\l+ getPathCost() : int\l+ getProcessedPath() : ArrayDeque<int[]>\l+ isPathFound() : boolean\l+ runAstar(agent : Agent)\l+ runAstar(box : Box)\l+ runAstar(mark_id : int, start_coordinates : int[], goal_coordinates : int[])\l}" ] 
    SearchMAState [ label = "{SearchMAState | + createDummyState(number_movables : int) : int[][]\l+ createNew(cell_coordinates : int[], total_gcost : int, f_value : int) : int[][]\l+ createStartState(movables : ArrayDeque<int[]>) : int[][]\l+ getColumn(index_pos : int, pos : int[]) : int\l+ getCostsIndex() : int\l+ getFCost(state : int[][]) : int\l+ getGCost(state : int[][]) : int\l+ getLocationIndex() : int\l+ getPositionHashed(state : int[][]) : int\l+ getPropsLenth() : int\l+ getRow(index_pos : int, pos : int[]) : int\l+ getStateCoordinates(state : int[][]) : int[]\l+ getStateUpdatedOf(prev_state : int[][], coordinates_index : int, cell_coordinates : int[], time_step : int, total_gcost : int, f_value : int) : int[]\l+ getTime(index_pos : int, pos : int[]) : int\l+ getTimeStep(movable_index : int, state : int[][]) : int\l+ getXCoordinate(movable_index : int, state : int[][]) : int\l+ getYCoordinate(movable_index : int, state : int[][]) : int\l+ setCostF(state : int[][], f_value : int)\l+ setCostG(state : int[][], total_gcost : int)\l+ setTimeStep(state : int[][], time_step : int)\l+ valueOf(String) : SearchMAState\l+ values() : SearchMAState[]\l}" ] 
    Costs [ label = "{Costs | + valueOf(String) : Costs\l+ values() : Costs[]\l}" ] 
    SearchSAState [ label = "{SearchSAState | + createDummyState() : int[][]\l+ createNew(cell_coordinates : int[], total_gcost : int, f_value : int) : int[][]\l+ getCostsIndex() : int\l+ getFCost(state : int[][]) : int\l+ getGCost(state : int[][]) : int\l+ getLocationIndex() : int\l+ getPositionHashed(state : int[][]) : int\l+ getPropsLenth() : int\l+ getStateCoordinates(state : int[][]) : int[]\l+ getTimeStep(state : int[][]) : int\l+ getXCoordinate(state : int[][]) : int\l+ getYCoordinate(state : int[][]) : int\l+ setCostF(state : int[][], f_value : int)\l+ setCostG(state : int[][], total_gcost : int)\l+ valueOf(String) : SearchSAState\l+ values() : SearchSAState[]\l}" ] 
    SearchTaskResult [ label = "{SearchTaskResult | + addGoalCoordinates(goalsCoordinatesOfGroup : int[])\l+ addLastConflict(last_conflicts : ArrayList<int[]>)\l+ addStartCoordinates(startCoordinatesOfGroup : int[])\l+ getAgentstIdxsToBoxesIdxs() : HashMap<Integer, int[]>\l+ getPath() : ArrayDeque<int[]>\l+ getStartGroupAgents() : int[]\l+ getTotalGroup() : int[][]\l+ getUUID(uniqueID : UUID) : UUID\l+ setAgentstIdxsToBoxesIdxs(agentsIdxsToBoxesIdxs : HashMap<Integer, int[]>)\l+ setGroup(startGroup : int[])\l+ setIndexAgents(indexAgents : int[])\l+ setTotalGroup(totalGroup : int[][])\l+ setTrackedGroup(trackedGroups : TrackedGroups)\l+ setUUID(uniqueID : UUID)\l}" ] 
    StateSearchMAFactory [ label = "{StateSearchMAFactory | + addPullConstraint(box_index : Integer, pull_move_cell : int[], standard_to_conflicts : ArrayList<SimulationConflict>)\l+ addToClosedSet(state : int[][])\l+ addToClosedTimeSet(state : int[][])\l+ avoidCoordinate(searchMultiAgentState : SearchState, neighbours : LinkedList<int[]>, coordinates_to_avoid : int[])\l+ createClosedSet()\l+ createClosedTimeSet()\l+ createDummyState() : int[][]\l+ createStartState(cell_coordinates : int[], total_gcost : int) : int[][]\l+ createStatesCameFrom()\l+ expandIntermediateState(state : int[][], standard_to_conflicts : ArrayList<SimulationConflict>) : ArrayDeque<int[][]>\l+ expandIntermediateStateWithAgents(pos_coordinates : int[], intermediate_node_costs : int[][], standard_to_conflicts : ArrayList<SimulationConflict>) : ArrayDeque<int[][]>\l+ expandIntermediateStateWithAgentsAndBoxes(pos_coordinates : int[], intermediate_node_costs : int[][], standard_to_conflicts : ArrayList<SimulationConflict>) : ArrayDeque<int[][]>\l+ expandStandardState(state : int[][], standard_to_conflicts : ArrayList<SimulationConflict>) : ArrayDeque<int[][]>\l+ expandStandardStateForAgentsAndBoxesMultiple(pos_coordinates : int[], g_cost : int, f_cost : int, standard_to_conflicts : ArrayList<SimulationConflict>) : ArrayDeque<int[][]>\l+ expandStandardStateWithAgents(pos_coordinates : int[], standard_node_costs : int[][], standard_to_conflicts : ArrayList<SimulationConflict>) : ArrayDeque<int[][]>\l+ expandStandardStateWithAgentsAndBoxes(pos_coordinates : int[], standard_node_costs : int[][], standard_to_conflicts : ArrayList<SimulationConflict>) : ArrayDeque<int[][]>\l+ expandStateStartingWithAgents(index_to_expand : int, pos_coordinates : int[], standard_node_costs : int[][], standard_to_conflicts : ArrayList<SimulationConflict>) : ArrayDeque<int[][]>\l+ expandStateStartingWithBoxes(coord_to_expand : int, pos_coordinates : int[], waiting_candidates : ArrayList<Integer>, intermediate_node_costs : int[][], standard_to_conflicts : ArrayList<SimulationConflict>) : ArrayDeque<int[][]>\l+ getBoxesCoordToAvoid(index_to_expand : int) : HashMap<Integer, int[]>\l+ getBoxesToAvoid(index_to_expand : int, position_to_expand : int[], pos_coordinates : int[]) : HashMap<Integer, int[]>\l+ getCameFrom(stateCoordinates : int[]) : int[]\l+ getCellCoordinates(state : int[][]) : int[]\l+ getGCost(state : int[][]) : int\l+ getGoalsCoordinatesGroup() : int[]\l+ getHeuristcOf(cell_coordinates : int[]) : int\l+ getHeuristcsMovablesOf(cell_coordinates : int[], heuristic_coordinates_output : int[]) : int\l+ getHeuristic(cell_coordinates : int[], goal_coordinates : int[]) : int\l+ getHeuristic(y : int, x : int, y_goal : int, x_goal : int) : int\l+ getStartCoordinatesGroup() : int[]\l+ getStartGroup() : int[]\l+ getStateHeuristcManhatten(cell_coordinates : int[]) : int\l+ getTimeStep(movable_index : int, state : int[][]) : int\l+ getXCoordinate(movable_index : int, state : int[][]) : int\l+ getYCoordinate(movable_index : int, state : int[][]) : int\l+ initIntermediateNodeCosts()\l+ initStandardNodeCosts()\l+ isGoal(state_coordinates : int[]) : boolean\l+ isInClosedSet(state : int[][]) : boolean\l+ isInClosedTimeSet(coordinates : int[]) : boolean\l+ isInCostSoFarUnused(next_pos : int[]) : boolean\l+ isIntermediateNode(pos_coordinates : int[]) : boolean\l+ isStandardNode(pos_coordinates : int[]) : boolean\l+ putCostSoFarUnused(state : int[][])\l+ removeCameFrom(next_key2 : int[], next_key : int[]) : boolean\l+ setAvoidanceCheckingRules(conflictAvoidanceCheckingRules : ConflictAvoidanceCheckingRules)\l+ setConflictsStandardStateExpansion(index_to_expand : int, pos_coordinates : int[], cell_pos_neighbour : int[], standard_to_conflicts : ArrayList<SimulationConflict>)\l+ setConflictsStandardStateExpansionForAgentsAndBoxesMultiple(indexes_to_expand : ArrayList<Integer>, pos_coordinates : int[], cell_pos_neighbours : ArrayList<int[]>, standard_to_conflicts : ArrayList<SimulationConflict>)\l+ setIndexBoxes(indexBoxes : int[])\l+ setStartGroup(start_group : int[], startCoordinates : int[], goalsCoordinates : int[], goalsNeighbours : HashMap<Integer, ArrayList<int[]>>)\l+ setUpAgentsWithBoxesFromGroup()\l+ setUpBoxesCoordToAvoid()\l+ updateCameFromPrevCell(came_from : HashMap<Integer, int[]>, state : int[][], previouse_coordinates : int[][])\l+ updateCameFromPrevCell(state : int[][], previouse_coordinates : int[])\l+ updateCameFromPrevCell2(state : int[][], previouse_coordinates : int[][])\l+ updateIntermediateNodeCosts(state : int[][]) : int[][]\l+ updateStandardNodeCosts(state : int[][]) : int[][]\l+ validateNeighbourOfGoal(pos_coordinates : int[], index_to_expand : int, position_to_expand : int[], neighbours : LinkedList<int[]>)\l}" ] 
    SearchState [ label = "{SearchState | + valueOf(String) : SearchState\l+ values() : SearchState[]\l}" ] 
    StateSearchSAFactory [ label = "{StateSearchSAFactory | + addToClosedSet(state : int[][])\l+ createClosedSet()\l+ createCostSoFar()\l+ createDummyState() : int[][]\l+ createState(cell_coordinates : int[], total_gcost : int, goal_coordinates : int[]) : int[][]\l+ createState(cell_neighbour : int[], neighbour_gcost : int, f_value : int) : int[][]\l+ getCellCoordinates(state : int[][]) : int[]\l+ getCostSoFar(next_ : int[]) : int[]\l+ getGCost(state : int[][]) : int\l+ getGoalsCoordinatesOfGroup() : int[]\l+ getStartCoordinatesOfGroup() : int[]\l+ getTimeStep(state : int[][]) : int\l+ getXCoordinate(state : int[][]) : int\l+ getYCoordinate(state : int[][]) : int\l+ isGoal(state_coordinates : int[], goal_coordinates : int[]) : boolean\l+ isInClosedSet(coordinate : int[], new_g_cost : int) : boolean\l+ isInClosedSetWithDeadline(coordinates : int[]) : boolean\l+ isInCostSoFar(next_pos : int[]) : boolean\l+ isInHeap(next_ : int[][]) : boolean\l+ mark_state_inqueue(state : int[][], is_in_heap : boolean)\l+ putCostSoFar(next_pos : int[], g_cost : int, f_cost : int, is_in_heap : boolean)\l+ putCostSoFar(state : int[][])\l+ setGoalsCoordinatesOfGroup(goalCoordinates : int[])\l+ setStartCoordinatesGroup(startCoordinates : int[])\l+ updateCameFromPrevCell(came_from : HashMap<int[], int[]>, state : int[][], previouse_coordinates : int[][])\l}" ] 
  }
  subgraph cluster_4 {
    label = "org.agents.markings";
    AgentField [ label = "{AgentField | + createAgentField() : int[]\l+ getColor(agent_object : int[]) : int\l+ getLenght() : int\l+ getNumber(agent_object : int[]) : int\l+ getSolved(agent_object : int[]) : SolvedStatus\l+ setColor(agent_object : int[], value : int)\l+ setNumber(agent_object : int[], value : int)\l+ setSolved(agent_object : int[], isSolved : SolvedStatus) : int\l+ valueOf(String) : AgentField\l+ values() : AgentField[]\l}" ] 
    BoxField [ label = "{BoxField | + createBoxField() : int[]\l+ getColor(box_object : int[]) : int\l+ getLenght() : int\l+ getLetter(box_object : int[]) : int\l+ getSolved(box_object : int[]) : SolvedStatus\l+ setColor(box_object : int[], value : int)\l+ setLetter(box_object : int[], value : int)\l+ setSolved(box_object : int[])\l+ setSolved(box_object : int[], isSolved : SolvedStatus)\l+ valueOf(String) : BoxField\l+ values() : BoxField[]\l}" ] 
    Color [ label = "{Color | + geFromName(color_name : String) : Color\l+ getColorCoded(color : Color) : int\l+ getFrom(color_code : int) : Color\l+ valueOf(String) : Color\l+ values() : Color[]\l}" ] 
    Coordinates [ label = "{Coordinates | + areEqual(coordinates_one : int[], coordinates_two : int[]) : boolean\l+ areNeighbours(prev__ : int[], next__ : int[]) : boolean\l+ areNeighbours(prev__ : int[], next__row : int, next__col : int) : boolean\l+ areNeighbours(prev_row : int, prev_col : int, next_row : int, next_col : int) : boolean\l+ createCoordinates() : int[]\l+ createCoordinates(time_step : int, row_index : int, col_index : int) : int[]\l+ getCol(index_pos : int, pos : int[]) : int\l+ getCol(pos : int[]) : int\l+ getCoordinatesAt(index : int, pos_coordinates : int[]) : int[]\l+ getEmptyInstance() : int[]\l+ getLenght() : int\l+ getNeighboursByIndexRanges(cell_pos : int[], index_agents : int[], agents_idx_to_boxes_idx : HashMap<Integer, int[]>, output_pairs : ArrayList<int[]>) : boolean\l+ getNumberOfCoordinates(goal_coordinates : int[]) : int\l+ getRow(index_pos : int, pos : int[]) : int\l+ getRow(pos : int[]) : int\l+ getTime(index_pos : int, pos : int[]) : int\l+ getTime(pos : int[]) : int\l+ isValid(pos_coordinates : int[]) : boolean\l+ setCol(index_pos : int, pos : int[], value : int)\l+ setCol(pos : int[], value : int)\l+ setCoordinateAtIndex(index : int, coordinates : int[], coordinate : int[])\l+ setRow(index_pos : int, pos : int[], value : int)\l+ setRow(pos : int[], value : int)\l+ setTime(index_pos : int, pos : int[], value : int)\l+ setTime(pos : int[], value : int)\l+ valueOf(String) : Coordinates\l+ values() : Coordinates[]\l}" ] 
    SolvedStatus [ label = "{SolvedStatus | + get(gotSolved : SolvedStatus) : int\l+ get(index : int) : SolvedStatus\l+ valueOf(String) : SolvedStatus\l+ values() : SolvedStatus[]\l}" ] 
  }
  subgraph cluster_5 {
    label = "org.agents.searchengine.normal";
    SearchEngineSANormal [ label = "{SearchEngineSANormal | + getCostCoordinate(cell_coordinate : int[], new_g_cost : int) : int\l+ getHeuristic(cell_coordinate : int[], goal_coordinate : int[]) : int\l+ getPath() : ArrayDeque<int[]>\l+ getPathCost() : int\l+ isPathFound() : boolean\l+ runAstar(agent : Agent)\l+ runAstar(box : Box)\l+ runAstar(mark_id : int, start_coordinates : int[], goal_coordinates : int[])\l}" ] 
    SearchSAStateNormal [ label = "{SearchSAStateNormal | + createDummyState() : int[][]\l+ createNew(cell_coordinates : int[], total_gcost : int, f_value : int) : int[][]\l+ getCostsIndex() : int\l+ getFCost(state : int[][]) : int\l+ getGCost(state : int[][]) : int\l+ getLocationIndex() : int\l+ getPositionHashed(state : int[][]) : int\l+ getPropsLenth() : int\l+ getStateCoordinates(state : int[][]) : int[]\l+ getTimeStep(state : int[][]) : int\l+ getXCoordinate(state : int[][]) : int\l+ getYCoordinate(state : int[][]) : int\l+ setCostF(state : int[][], f_value : int)\l+ setCostG(state : int[][], total_gcost : int)\l+ valueOf(String) : SearchSAStateNormal\l+ values() : SearchSAStateNormal[]\l}" ] 
    Costs [ label = "{Costs | + valueOf(String) : Costs\l+ values() : Costs[]\l}" ] 
    StateSearchSAFactoryNormal [ label = "{StateSearchSAFactoryNormal | + addToClosedSet(state : int[][])\l+ createClosedSet()\l+ createCostSoFar()\l+ createDummyState() : int[][]\l+ createState(cell_coordinates : int[], total_gcost : int, goal_coordinates : int[]) : int[][]\l+ createState(cell_neighbour : int[], neighbour_gcost : int, f_value : int) : int[][]\l+ getCellCoordinates(state : int[][]) : int[]\l+ getCostSoFar(next_ : int[]) : int[]\l+ getGCost(state : int[][]) : int\l+ getTimeStep(state : int[][]) : int\l+ getXCoordinate(state : int[][]) : int\l+ getYCoordinate(state : int[][]) : int\l+ isGoal(state_coordinates : int[], goal_coordinates : int[]) : boolean\l+ isInClosedSet(coordinate : int[], new_g_cost : int) : boolean\l+ isInClosedSetWithDeadline(coordinates : int[]) : boolean\l+ isInCostSoFar(next_pos : int[]) : boolean\l+ isInHeap(next_ : int[][]) : boolean\l+ mark_state_inqueue(state : int[][], is_in_heap : boolean)\l+ putCostSoFar(next_pos : int[], g_cost : int, f_cost : int, is_in_heap : boolean)\l+ putCostSoFar(state : int[][])\l+ updateCameFromPrevCell(came_from : HashMap<int[], int[]>, state : int[][], previouse_coordinates : int[][])\l}" ] 
  }
  subgraph cluster_6 {
    label = "org.agents.planning.conflicts";
    ConflictAvoidanceCheckingRules [ label = "{ConflictAvoidanceCheckingRules | + addPathsToTaskScheduledPahs(group1 : int[], group2 : int[], group_marks_total : int[], new_path_group : ArrayDeque<int[]>) : boolean\l+ addTaskScheduledPaths(taskScheduled : TaskScheduled)\l+ clearTaskScheduledList() : boolean\l+ discardConflictsMA(neighbours : ArrayDeque<int[]>, conflicts_avoidance : ArrayDeque<int[]>) : LinkedList<int[]>\l+ getCheckConflictAvoidanceTable(coordinates : int[], next_cells : ArrayDeque<int[]>)\l+ getConflictsTable() : ConflictAvoidanceTable\l+ getConsistentHeuristic(mark_id : int, cost_time : int, cell_coordinates : int[], goal_coordinates : int[]) : int\l+ getConsistentHeuristic(mark_id : int, cost_time : int, y : int, x : int, y_goal : int, x_goal : int) : int\l+ getCostTimeCoordinate(mark_id : int, cell_coordinate : int[]) : int\l+ getFreeNeighboursMA(mark_id : int, coordinate : int[], conflicts_avoidance : ArrayDeque<int[]>) : LinkedList<int[]>\l+ getFreeNeighboursSA(coordinate : int[], mark_id : int) : ArrayDeque<int[]>\l+ getHeuristicOf(mark_id : int, cell_coordinate : int[], goal_coordinate : int[]) : int\l+ getHeuristicOf(mark_id : int, cost_time : int, y : int, x : int, y_goal : int, x_goal : int) : int\l+ getIllegalPathsStore() : IllegalPathsStore\l+ getManhattenHeuristic(cell_coordinates : int[], goal_coordinates : int[]) : int\l+ getManhattenHeuristic(y : int, x : int, y_goal : int, x_goal : int) : int\l+ getValidTasks() : ArrayList<TaskScheduled>\l+ removeTaskScheduledFor(group : int[]) : boolean\l+ replaceTaskScheduledFor(group : int[], new_path : ArrayDeque<int[]>) : boolean\l+ setIllegalPathsOfGroup(start_group : int[], conflicting_group : int[], conflicting_paths : int[][][])\l+ setNextConflictedMovables(colided_ids : int[]) : boolean\l+ setSearchState(searchState : SearchState) : boolean\l+ setTrackedGroups(trackedGroups : TrackedGroups)\l}" ] 
    SearchState [ label = "{SearchState | + valueOf(String) : SearchState\l+ values() : SearchState[]\l}" ] 
    ConflictAvoidanceTable [ label = "{ConflictAvoidanceTable | + addMarkedPathAndPopped(path : ArrayDeque<int[]>, number_mark : int)\l+ addMarkedPathsFor(group_marks_total : int[], paths : ArrayDeque<int[]>)\l+ getAllPathsFromtable() : ArrayList[]\l+ getAllUnGroupedIDs() : int[]\l+ getAllUnGroupedIDsAsSet() : Set<Integer>\l+ getEdgeConflicts(prev_cell_location : int[], cell_location : int[], index : int) : boolean\l+ getGroupOf(mark_id : int) : Set<Integer>\l+ getMarkedPaths(group_marks : Set<Integer>) : int[][][]\l+ getMarkedPaths(group_marks : int[]) : int[][][]\l+ getMarkedPathsCloned(group_marks : int[]) : int[][][]\l+ getPathLenght(group__one : int[]) : int\l+ groupIDs(group_one : int[], group_two : int[]) : int[]\l+ groupIDs(mark_id1 : int, mark_id2 : int)\l+ isCellOrEdgeConflicts(cell_location : int[], prev_cell_location : int[], index : int) : boolean\l+ isNewConflict(group_one : int[], group_two : int[]) : boolean\l+ isUnGrouped(mark_id : int) : boolean\l+ removeCellConflicts(prev_cell_location : int[], path : ArrayDeque<int[]>)\l+ removeConflictsInPath(prev_cell_location : int[], path : ArrayDeque<int[]>, next_conflicts : ArrayList<int[]>) : int\l+ removeIllegalConflicts(prev_cell_location : int[], path : ArrayDeque<int[]>, illegal_paths : ArrayList<int[][][]>)\l+ replaceMarkedPathFor(group_marks : int[], group_paths : ArrayDeque<int[]>)\l+ replaceMarkedPathFor(mark_id : int, path : ArrayDeque<int[]>)\l+ setNextOverlapedMovables(colided_ids : int[]) : boolean\l+ setTrackedGroups(trackedGroups : TrackedGroups)\l}" ] 
    IllegalPath [ label = "{IllegalPath | + addPaths(start_group_paths : int[][][], conflicting_paths : int[][][])\l+ getConflictingGroup() : int[]\l+ getDeadlineConstraint() : int[]\l+ getLatestTimeForConflictingPath() : int[]\l+ getPaths() : ArrayList<int[][][]>\l+ getStartGroup() : int[]\l+ setChecked(isChecked : boolean)\l+ setDeadlineConstraint() : int[]\l}" ] 
    IllegalPathsStore [ label = "{IllegalPathsStore | + addIlegalPath(illegalPath : IllegalPath)\l+ checkIllegalPath(mark_id : int) : ArrayList<int[][][]>\l+ getAllConflicts(mark_id : int, groups : int[]) : ArrayList<SimulationConflict>\l+ getConflicts(mark_ids : int[], groups : int[]) : ArrayList<SimulationConflict>\l+ getIllegalPath(mark_id : int) : IllegalPath\l+ pollNextIllegalPath() : IllegalPath\l+ removeAllIlegalPaths() : boolean\l}" ] 
    PathsStoreQuerying [ label = "{PathsStoreQuerying | + getAllOverlapsFor(first_path : int[][], second_path : int[][]) : ArrayDeque<int[]>\l+ getFirstOverlapFor(first_path : int[][], second_path : int[][]) : int[]\l+ getIndexFor(mark_id : int) : int\l+ getMergedGroupOfTwo(groups_marks : int[][]) : int[]\l+ getNumberOfPaths() : int\l+ getPathCloneFor(mark_id : int) : int[][]\l+ getPathFor(mark_id : int) : int[][]\l+ getPathLenght(mark_id : int) : int\l+ getPathsCloneForGroup(group_marks : int[]) : int[][][]\l+ getPathsColumnsNo() : int\l+ getPathsForGroup(group_marks : Set<Integer>) : int[][][]\l+ getPathsForGroup(group_marks : int[]) : int[][][]\l+ getPathsRowsNo() : int\l+ getTimeStep(mark_id : int, cell_location : int[]) : int\l+ isOverlap(first_path : int[][], second_path : int[][]) : boolean\l+ removePath(group_marks : int[]) : boolean\l+ removePath(mark_id : int) : boolean\l+ setCellLocationOf(group_marks : int[], cell_locations : int[])\l+ setCellLocationOf(groups_marks : int[], paths : ArrayDeque<int[]>)\l+ setCellLocationOf(groups_marks : int[][], cell_locations : int[])\l+ setCellLocationOf(mark_id : int, cell_location : int[])\l+ setCellLocationOf(mark_id : int, path : ArrayDeque<int[]>)\l+ setUpTracked(trackedGroups : TrackedGroups)\l}" ] 
  }
  subgraph cluster_7 {
    label = "org.agents.planning.constraints";
    PullConstraint [ label = "{PullConstraint | + addNextMoveCell(pull_move_cell : int[])\l+ getBox_index() : int\l+ getConstraint_cells() : ArrayList<int[]>\l+ getCoordinatesToAvoid() : ArrayList<int[]>\l+ getMaxTimeDeadline() : int[]\l}" ] 
  }
  subgraph cluster_8 {
    label = "org.agents.planning.schedulling";
    DivideAndScheduleMovables [ label = "{DivideAndScheduleMovables | + getAgentsScheduled(agents_to_schedule : LinkedList<Agent>) : MovablesScheduling\l+ getAgentsScheduledRandom(agents : LinkedList<Agent>) : ArrayDeque<Agent>\l+ getBoxesScheduled() : ArrayDeque<Box>\l+ getSearchResults() : TaskScheduled\l+ setAgentsGoalsFound(searchTaskResult : SearchTaskResult)\l+ setAgentsGoalsFound(start_group_agents : int[], path_found : ArrayDeque<int[]>)\l}" ] 
    MovablesScheduling [ label = "{MovablesScheduling | + getAgentsIds() : Set<Integer>\l+ getAgentsIdsToBoxesIds() : HashMap<Integer, Set<Integer>>\l+ getAgentsScheduled() : ArrayList<Agent>\l+ getBoxesIds() : Set<Integer>\l+ getBoxesScheduled() : LinkedList<Box>\l+ getMatchedAgentsBoxes(task_scheduled : TaskScheduled) : SearchScheduled\l+ getMatchedAgentsBoxesIndexes2(agents_group_ids : int[], box_group_ids : int[], agents_ids_to_boxes_ids : HashMap<Integer, Set<Integer>>) : SearchScheduled\l+ getSearchResults() : TaskScheduled\l+ getStartGroupAgentsBoxes_ToSearch() : SearchScheduled\l+ getTrackedGroups() : TrackedGroups\l+ setAgentsScheduledSolvedResults(searchTaskResult : SearchTaskResult, final_agents_position : int[], solvedStatus : SolvedStatus) : boolean\l+ setUpPair(agent_id : Integer, box_target_id : Integer)\l}" ] 
    SearchScheduled [ label = "{SearchScheduled | + agentsAndBoxes(start_group : int[], start_boxes_length : int)\l+ agentsOnly(start_group : int[])\l+ getAgentstIdxsToBoxesIdxs() : HashMap<Integer, int[]>\l+ getGoals_coordinates() : int[]\l+ getGoals_neighbours() : HashMap<Integer, ArrayList<int[]>>\l+ getGroup() : int[]\l+ getGroup_marks_ids() : int[]\l+ getIndexBoxes() : int[]\l+ getIndexOfAgents() : int[]\l+ getStartGroupOfAgents() : int[]\l+ getStart_coordinates() : int[]\l+ getTotalGroup() : int[][]\l+ getTotalGroup(totalGroup : int[][]) : int[][]\l+ getUUID() : UUID\l+ setAgentsIdxsToBoxesIdxs(agentsIdxs_to_boxesIdxs : HashMap<Integer, int[]>)\l+ setGroup(group : int[])\l+ setStartGroup(searchMultiAgentState : SearchState)\l+ setState(nextGoalToBox : int)\l+ setStateGoals(nextGoalToBox : int, agt_id : int, box_id : int)\l+ setTotalGroup(totalGroup : int[][])\l+ setUUID(uniqueID : UUID)\l}" ] 
    Synchronization [ label = "{Synchronization | + decreaseCentralTime(time_step : int) : int\l+ getCentralTime() : int\l+ getMinMaxTime(paths : HashMap<Integer, ArrayDeque<int[]>>) : int[]\l+ increaseCentralTime(time_step : int) : int\l+ processTaskScheduled(task : TaskScheduled)\l+ resetCentralTime()\l}" ] 
    TaskScheduled [ label = "{TaskScheduled | + add(agent : Agent, agent_path : ArrayDeque<int[]>)\l+ add(box : Box, box_path : ArrayDeque<int[]>)\l+ addAgents(agents_solved_mark_ids : ArrayList<Integer>)\l+ addAggentsBoxes(agents_to_boxes : HashMap<Integer, ArrayDeque<Integer>>)\l+ addClockTime(clockTime : int)\l+ addValidMovables(agts_total : ArrayList<Integer>, bxs_total : ArrayList<Integer>)\l+ getAgentsSolved(solvedStatus : SolvedStatus) : ArrayList<Integer>\l+ getAgentsToBoxes() : Set<Map.Entry<Integer, ArrayDeque<Integer>>>\l+ getAgentsToPaths() : HashMap<Integer, ArrayDeque<int[]>>\l+ getBoxesToPaths() : HashMap<Integer, ArrayDeque<int[]>>\l+ getClock_time() : int\l+ getGroupMarksSolved() : Set<Integer>\l+ getGroupsMarks() : int[]\l+ getGroupsTotalPath() : ArrayDeque<int[]>\l+ getValidAgents() : int[]\l+ getValidBoxes() : int[]\l+ isSchedulable() : boolean\l+ isTheSameGroupAs(group_test : int[]) : boolean\l+ replacePathsFor(group_marks : int[], new_path : ArrayDeque<int[]>)\l}" ] 
    TrackedGroups [ label = "{TrackedGroups | + getAgentsScheduledIds() : Set<Integer>\l+ getAllUnGroupedIDs() : Set<Integer>\l+ getBoxesScheduledIds() : Set<Integer>\l+ getGroupSize() : int\l+ getIndexFor(mark_id : int) : int\l+ getTrackedIds() : Collection<? extends Integer>\l+ initIdsIndexes(start_group_agents : int[], boxes : int[])\l+ initIdsIndexesRandom()\l}" ] 
  }
  subgraph cluster_9 {
    label = "org.agents.searchengine.heuristics.comparators";
    AgentConflictComparator [ label = "{AgentConflictComparator | + compare(getNumberAgentsConflicts1 : int, getNumberAgentsConflicts2 : int) : int\l}" ] 
  }
  subgraph cluster_10 {
    label = "org.agents.planning.conflicts.dto";
    CorridorConflict [ label = "{CorridorConflict | + getCoordinatesToAvoid() : ArrayList<int[]>\l+ getMaxTimeDeadline() : int[]\l}" ] 
    EdgeConflict [ label = "{EdgeConflict | + addConflictedEdge(mark_id_conflicted : int, coordinate_edge_start : int[], coordinates_edge_end : int[])\l+ getCoordinatesToAvoid() : ArrayList<int[]>\l+ getMaxTimeDeadline() : int[]\l+ getTimeEdgeEnd(edge : int[][]) : int\l+ getTimeEdgeStart(edge : int[][]) : int\l}" ] 
    MovablesConflict [ label = "{MovablesConflict | + getCoordinatesToAvoid() : ArrayList<int[]>\l+ getMaxTimeDeadline() : int[]\l}" ] 
    SimulationConflict [ label = "{SimulationConflict | + getConflictedIds() : Set<Integer>\l+ getCoordinatesToAvoid() : ArrayList<int[]>\l+ getMarkedId() : int\l+ getMaxTimeDeadline() : int[]\l}" ] 
    VertexConflict [ label = "{VertexConflict | + addConflictedCell(mark_id_conflicted : int, coordinate_conflicted : int[])\l+ getCoordinatesToAvoid() : ArrayList<int[]>\l+ getMaxTimeDeadline() : int[]\l}" ] 
  }
  PullAction -> Direction [ dir=back arrowtail=odiamond color=slategray];
  GroupSearch -> SearchScheduled [ dir=back arrowtail=odiamond color=slategray];
  MoveAction -> Direction [ dir=back arrowtail=odiamond color=slategray];
  IllegalPathsStore -> IllegalPath [ dir=back arrowtail=odiamond color=slategray];
  PushAction -> Direction [ dir=back arrowtail=odiamond color=slategray];
  StateSearchMAFactory -> ConflictAvoidanceCheckingRules [ dir=back arrowtail=odiamond color=slategray];
  PathsStoreQuerying -> TrackedGroups [ dir=back arrowtail=odiamond color=slategray];
  MovablesScheduling -> Agent [ dir=back arrowtail=odiamond color=slategray];
  ActionType -> Action [ dir=forward arrowhead=odiamond color=slategray];
  Action -> ActionType [ dir=back arrowtail=odiamond color=slategray];
  ConflictAvoidanceCheckingRules -> IllegalPathsStore [ dir=back arrowtail=odiamond color=slategray];
  GroupIndependenceDetection -> ConflictAvoidanceTable [ dir=back arrowtail=odiamond color=slategray];
  GroupSearch -> SearchTaskResult [ dir=back arrowtail=odiamond color=slategray];
  StateSearchMAFactory -> SearchState [ dir=back arrowtail=odiamond color=slategray];
  SearchState -> StateSearchMAFactory [ dir=forward arrowhead=odiamond color=slategray];
  IllegalPathsStore -> ConflictAvoidanceTable [ dir=back arrowtail=odiamond color=slategray];
  SearchEngineSANormal -> ConflictAvoidanceCheckingRules [ dir=back arrowtail=odiamond color=slategray];
  ConflictAvoidanceCheckingRules -> TaskScheduled [ dir=back arrowtail=odiamond color=slategray];
  GroupIndependenceDetection -> ConflictAvoidanceCheckingRules [ dir=back arrowtail=odiamond color=slategray];
  ConflictAvoidanceTable -> PathsStoreQuerying [ dir=back arrowtail=odiamond color=slategray];
  ParsingState -> SearchClient [ dir=forward arrowhead=odiamond color=slategray];
  SearchStrategy -> ConflictAvoidanceCheckingRules [ dir=back arrowtail=odiamond color=slategray];
  SearchStrategy -> MovablesScheduling [ dir=back arrowtail=odiamond color=slategray];
  SearchTaskResult -> TrackedGroups [ dir=back arrowtail=odiamond color=slategray];
  ConflictAvoidanceCheckingRules -> ConflictAvoidanceTable [ dir=back arrowtail=odiamond color=slategray];
  GroupIndependenceDetection -> PathProcessing [ dir=back arrowtail=odiamond color=slategray];
  MovablesScheduling -> Box [ dir=back arrowtail=odiamond color=slategray];
  DivideAndScheduleMovables -> Agent [ dir=back arrowtail=odiamond color=slategray];
  Costs -> SearchSAStateNormal [ dir=forward arrowhead=odiamond color=slategray];
  GroupSearch -> ConflictAvoidanceCheckingRules [ dir=back arrowtail=odiamond color=slategray];
  StateSearchSAFactoryNormal -> SearchSAStateNormal [ dir=back arrowtail=odiamond color=slategray];
  GroupIndependenceDetection -> SearchScheduled [ dir=back arrowtail=odiamond color=slategray];
  SearchScheduled -> SearchState [ dir=back arrowtail=odiamond color=slategray];
  GroupIndependenceDetection -> GroupSearch [ dir=back arrowtail=odiamond color=slategray];
  Costs -> SearchMAState [ dir=forward arrowhead=odiamond color=slategray];
  SearchState -> ConflictAvoidanceCheckingRules [ dir=forward arrowhead=odiamond color=slategray];
  ConflictAvoidanceCheckingRules -> SearchState [ dir=back arrowtail=odiamond color=slategray];
  ConflictAvoidanceTable -> TrackedGroups [ dir=back arrowtail=odiamond color=slategray];
  GroupSearch -> SearchState [ dir=back arrowtail=odiamond color=slategray];
  Costs -> SearchSAState [ dir=forward arrowhead=odiamond color=slategray];
  SearchEngineSA -> ConflictAvoidanceCheckingRules [ dir=back arrowtail=odiamond color=slategray];
  IllegalPath -> SimulationConflict [ dir=back arrowtail=odiamond color=slategray];
  GroupSearch -> TrackedGroups [ dir=back arrowtail=odiamond color=slategray];
  GroupSearch -> TrackedGroups [ dir=back arrowtail=odiamond color=slategray];
  ConflictingPair -> Pair2 [arrowhead=empty color=slategray];
  CoordinateOf3 -> PairOf3 [arrowhead=empty color=slategray];
  MoveAction -> Action [arrowhead=empty color=slategray];
  PullAction -> Action [arrowhead=empty color=slategray];
  PushAction -> Action [arrowhead=empty color=slategray];
  CorridorConflict -> SimulationConflict [arrowhead=empty color=slategray];
  CorridorConflict -> SimulationConflict [arrowhead=empty color=slategray];
  EdgeConflict -> SimulationConflict [arrowhead=empty color=slategray];
  EdgeConflict -> SimulationConflict [arrowhead=empty color=slategray];
  MovablesConflict -> SimulationConflict [arrowhead=empty color=slategray];
  MovablesConflict -> SimulationConflict [arrowhead=empty color=slategray];
  VertexConflict -> SimulationConflict [arrowhead=empty color=slategray];
  VertexConflict -> SimulationConflict [arrowhead=empty color=slategray];
  PullConstraint -> SimulationConflict [arrowhead=empty color=slategray];
  PullConstraint -> SimulationConflict [arrowhead=empty color=slategray];
}